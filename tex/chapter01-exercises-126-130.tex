\begin{enumerate}

    \item [1.26]

          Using the solution you gave to Exercise 1.25, give a formal description of the machines $T_1$ and $T_2$ depicted in Exercise 1.24.

    \item [1.27]
          Read the informal definition of the finite state transducer given in Exercise 1.24. Give the state diagram of an FST with the following behavior. Its input and output alphabets are $\{0,1\}$. Its output string is identical to the input string on the even positions but inverted on the odd positions. For example, on input $0000111$ it should output $1010010$.

          \begin{figure}[H]
              \centering
              \begin{tikzpicture}[
                  ]
                  \node[state, initial] (q0) {};
                  \node[state, right of=q0] (q1) {};
                  \draw
                  (q0) edge[bend left, above] node{$\genfrac{}{}{0pt}{}{1 \slash 0}{0 \slash 1}$} (q1)
                  (q1) edge[bend left, below] node{$\genfrac{}{}{0pt}{}{1 \slash 1}{0 \slash 0}$} (q0);
              \end{tikzpicture}
          \end{figure}

    \item [1.28]
          Convert the following regular expressions to NFAs using the procedure given in Theorem 1.54. In all parts, $\Sigma=\{a,b\}$.
          \begin{enumerate}
              \item $a(abb)^\ast \cup b$
                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}[
                                styleSmall/.style={minimum size=4mm},
                                node distance=1.5cm,
                            ]
                            \node[state, initial, styleSmall] (q0) {};
                            \node[state, above right of=q0, styleSmall] (q1_s) {};
                            \node[state, right of=q1_s, styleSmall] (q1_1) {};
                            \node[state, right of=q1_1, styleSmall, accepting] (q1_e) {};
                            \node[state, right of=q1_e, styleSmall] (q1_2) {};
                            \node[state, right of=q1_2, styleSmall] (q1_3) {};
                            \node[state, right of=q1_3, styleSmall, accepting] (q1_4) {};
                            \node[state, below right of=q0, styleSmall] (q2_s) {};
                            \node[state, right of=q2_s, styleSmall, accepting] (q2_1) {};
                            \draw
                            (q0) edge[above] node{$\epsilon$} (q1_s)
                            (q1_s) edge[above] node{$a$} (q1_1)
                            (q1_1) edge[above] node{$\epsilon$} (q1_e)
                            (q1_e) edge[above] node{$a$} (q1_2)
                            (q1_2) edge[above] node{$b$} (q1_3)
                            (q1_3) edge[above] node{$b$} (q1_4)
                            (q1_4) edge[bend left, below] node{$\epsilon$} (q1_e)
                            (q0) edge[above] node{$\epsilon$} (q2_s)
                            (q2_s) edge[above] node{$b$} (q2_1);
                        \end{tikzpicture}
                        \caption{NFA for $a(abb)^\ast \cup b$}
                    \end{figure}
              \item $a^+ \cup (ab)^+$

                    $a^+ \cup (ab)^+$ = $aa^\ast \cup ab(ab)^\ast$
                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}[
                                styleSmall/.style={minimum size=4mm},
                                node distance=1.5cm,
                            ]
                            \node[state, initial, styleSmall] (q0) {};
                            \node[state, above right of=q0, styleSmall] (q1_s) {};
                            \node[state, right of=q1_s, styleSmall] (q1_1) {};
                            \node[state, right of=q1_1, styleSmall, accepting] (q1_e) {};
                            \node[state, right of=q1_e, styleSmall] (q1_2) {};
                            \node[state, right of=q1_2, styleSmall, accepting] (q1_3) {};
                            \node[state, below right of=q0, styleSmall] (q2_s) {};
                            \node[state, right of=q2_s, styleSmall, accepting] (q2_1) {};
                            \node[state, right of=q2_1, styleSmall, accepting] (q2_2) {};
                            \draw
                            (q0) edge[above] node{$\epsilon$} (q1_s)
                            (q1_s) edge[above] node{$a$} (q1_1)
                            (q1_1) edge[above] node{$b$} (q1_e)
                            (q1_e) edge[above] node{$a$} (q1_2)
                            (q1_2) edge[above] node{$b$} (q1_3)
                            (q1_3) edge[bend left, below] node{$\epsilon$} (q1_e)
                            (q0) edge[above] node{$\epsilon$} (q2_s)
                            (q2_s) edge[above] node{$a$} (q2_1)
                            (q2_1) edge[above] node{$a$} (q2_2)
                            (q2_2) edge[bend left, below] node{$\epsilon$} (q2_1);
                        \end{tikzpicture}
                        \caption{NFA for $a^+ \cup (ab)^+$}
                    \end{figure}
              \item $(a \cup b^+)a^+b$

                    $(a \cup b^+)a^+b$  = $(a \cup bb^\ast)aa^\ast b$

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}[
                                styleSmall/.style={minimum size=4mm},
                                node distance=1.5cm,
                            ]
                            \node[state, initial, styleSmall] (q0) {};
                            \node[state, above right of=q0, styleSmall] (q1_s) {};
                            \node[state, right of=q1_s, styleSmall] (q1_1) {};
                            \node[state, above right of=q1_1, styleSmall] (q1_e) {};
                            \node[state, below right of=q0, styleSmall] (q2_s) {};
                            \node[state, right of=q2_s, styleSmall] (q2_1) {};
                            \node[state, below right of=q1_1, styleSmall] (q3_s) {};
                            \node[state, right of=q3_s, styleSmall] (q3_1) {};
                            \node[state, above right of=q3_1, styleSmall] (q3_2) {};
                            \node[state, below right of=q3_1, styleSmall, accepting] (q3_3) {};
                            \draw
                            (q0) edge[above] node{$\epsilon$} (q1_s)
                            (q1_s) edge[above] node{$b$} (q1_1)
                            (q1_1) edge[below right] node{$b$} (q1_e)
                            (q1_e) edge[bend right, above] node{$\epsilon$} (q1_1)
                            (q0) edge[above] node{$\epsilon$} (q2_s)
                            (q2_s) edge[above] node{$a$} (q2_1)
                            (q2_1) edge[above] node{$\epsilon$} (q3_s)
                            (q1_1) edge[left] node{$\epsilon$} (q3_s)
                            (q3_s) edge[above] node{$a$} (q3_1)
                            (q3_1) edge[above] node{$a$} (q3_2)
                            (q3_2) edge[bend left, below] node{$\epsilon$} (q3_1)
                            (q3_1) edge[below] node{$b$} (q3_3);
                        \end{tikzpicture}
                        \caption{NFA for $(a \cup b^+)a^+b$}
                    \end{figure}
          \end{enumerate}
    \item [1.29]
          Use the pumping lemma to show that the following languages are not regular.
          \begin{enumerate}
              \item $A_1 =\{0^n 1^n 2^n | ~n \geq 0\}$
              \item $A_2 =\{www|~w \in \{a,b\}^\ast\}$
              \item $A_3 = \{ a^{2^n} | ~n \geq 0\}$  (Here, $a^{2^n}$ means a string of $2^n$ $a$â€™s.)
          \end{enumerate}

          \begin{enumerate}
              \item Let $p$ be the pumping length, and consider the string $0^p 1^p 2^p$. We can pump one symbol at a time ($0$, $1$ or $2$) but it changes the number of symbols of that type. So, the string is not in the language. Or we can pump two different symbols at a time (zeros and ones or ones and twos) but the order of symbols will change.

                    Therefore, $A_1$ is not regular.

              \item Let $w$ be any string of length $p$ with form $a^{p-1}ba^{p-1}ba^{p-1}b$. We can pump part of string with only one $b$, but it will change the number of $b$'s in the string but number of $b$'s won't be divided by 3. Therefore, $A_2$ is not regular.

              \item Choose s to be the string $a^{2^p}$. Because $s$ is a member of $A_3$ and $s$ is longer than $p$, can be split into three pieces, $s = xyz$. $|xy|\geq p$. Furthermore, $p < 2^p$ and so $|y| < 2^p$. Therefore, $|xyyz| = |xyz|+|y| < 2^p+2^p =2^{p+1}$. $|y| > 0$ so $2^p < |xyyz| < 2^{p+1}$. The length of $xyyz$ cannot be a power of $2$. Hence $xyyz$ is not a member of $A_3$, a contradiction.Therefore, $A_3$ is not regular.
          \end{enumerate}

    \item [1.30]

          Describe the error in the following "proof" that $0^\ast1^\ast$ is not a regular language. (An error must exist because $0^\ast1^\ast$ is regular.) The proof is by contradiction. Assume that $0^\ast1^\ast$ is regular. Let $p$ be the pumping length for $0^\ast1^\ast$ given by the pumping lemma. Choose s to be the string $0^p1^p$. You know that $s$ is a member of $0^\ast1^\ast$, but Example 1.73 shows that $s$ cannot be pumped. Thus you have a contradiction. So $0^\ast1^\ast$ is not regular.

          We can split s into three pieces, $s = xyz$ with $y$ contains only $0$'s or only $1$'s. Then, we can pump $y$ and the number of $0$'s or $1$'s will change. Therefore, $s$ isn't good choice for pumping lemma $0^\ast1^\ast$ can be regular.

\end{enumerate}
