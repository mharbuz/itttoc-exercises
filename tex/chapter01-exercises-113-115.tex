\begin{enumerate}

    \item [1.13]

          Let $F$ be the language of all strings over $\{0,1\}$ that do not contain a pair of $1$s that are separated by an odd number of symbols. Give the state diagram of a DFA with five states that recognizes $F$. (You may find it helpful first to find a 4-state NFA for the complement of $F$.) blab

          $\overline{F} = \{w|w~ \text{contains a pair of }1\text{'s that are separated by an odd number of symbols}\}$

          \begin{figure}[H]
              \centering
              \begin{tikzpicture}
                  \node[state, initial] (q0) {};
                  \node[state, right of=q0] (q1) {};
                  \node[state, above of=q1] (q2) {};
                  \node[state, accepting, right of=q1] (q3) {};
                  \draw
                  (q0) edge[above] node{$1$} (q1)
                  (q0) edge[bend right, below] node{$1$} (q2)
                  (q2) edge[above] node{$1$} (q3)
                  (q2) edge[bend right, above] node{$1$} (q3)
                  (q3) edge[loop above] node{$0$} (q3);
              \end{tikzpicture}
              \caption{NFA with four states that recognizes $\overline{F}$}
          \end{figure}
    \item [1.14]
          \begin{enumerate}
              \item Show that if $M$ is a DFA that recognizes language $B$, swapping the accept and nonaccept states in $M$ yields a new DFA recognizing the complement of $B$.Conclude that the class of regular languages is closed under complement.

                    Every state in DFA has a transition for every symbol in the alphabet. For every possible word, the DFA will end up in either an accept state or a nonaccept state. If we swap the accept and nonaccept states in $M$, the new DFA will accept the complement of the language $B$.

              \item Show by giving an example that if $M$ is an NFA that recognizes language $C$, swapping the accept and non-accept states in $M$ doesnâ€™t necessarily yield a new NFA that recognizes the complement of $C$. Is the class of languages recognized by NFAs closed under complement? Explain your answer.

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, initial] (q0) {};
                            \node[state, accepting, right of=q0] (q1) {};
                            \draw
                            (q0) edge[above] node{$0,1$} (q1)
                            (q0) edge[loop above] node{$0$} (q0);
                        \end{tikzpicture}
                        \caption{example NFA}
                        \begin{tikzpicture}
                            \node[state, accepting, initial] (q0) {};
                            \node[state, right of=q0] (q1) {};
                            \draw
                            (q0) edge[above] node{$0,1$} (q1)
                            (q0) edge[loop above] node{$0$} (q0);
                        \end{tikzpicture}
                        \caption{example NFA with changed states acceptance}
                    \end{figure}

                    NFA accepts a string if there is at least one path that leads to an accept state. If we swap the accept and non-accept states in $M$, the new NFA will not necessarily accept the complement of the language $C$. The class of languages recognized by NFAs is not closed under complement.
          \end{enumerate}
    \item [1.17]
          \begin{enumerate}
              \item Give an NFA recognizing the language $(01 \cup 001 \cup 010)^\ast$
                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, initial] (q0) {};
                            \node[state, above right of=q0] (q1) {};
                            \node[state, right of=q0] (q2) {};
                            \node[state, below right of=q0] (q3) {};
                            \node[state, right of=q1] (q11) {};
                            \node[state, right of=q11] (q12) {};

                            \node[state, right of=q2] (q21) {};
                            \node[state, right of=q21] (q22) {};
                            \node[state, right of=q22] (q23) {};
                            \node[state, right of=q3] (q31) {};
                            \node[state, right of=q31] (q32) {};
                            \node[state, right of=q32] (q33) {};

                            \node[state, accepting, right of=q23] (qend) {};
                            \draw
                            (q0) edge[above] node{$\epsilon$} (q1)
                            (q0) edge[above] node{$\epsilon$} (q2)
                            (q0) edge[above] node{$\epsilon$} (q3)
                            (q1) edge[loop above] node{$1$} (q1)
                            (q2) edge[loop above] node{$0$} (q2)

                            (q12) edge[above] node{$\epsilon$} (qend)
                            (q23) edge[above] node{$\epsilon$} (qend)
                            (q33) edge[above] node{$\epsilon$} (qend)
                            (qend) edge[bend right, above] node{$\epsilon$} (q0);
                        \end{tikzpicture}
                        \caption{NFA recognizing the language $(01 \cup 001 \cup 010)^\ast$}
                    \end{figure}
              \item Convert this NFA to an equivalent DFA. Give only the portion of the DFA that is reachable from the start state.
          \end{enumerate}
    \item [1.18]
          Give regular expressions generating the languages of Exercise 1.6.
          \begin{enumerate}
              \item $\{w|w~ \text{begins with a }1\text{ and ends with a }0\}$
                    \begin{align*}
                        1(0+1)^*0
                    \end{align*}
              \item $\{w|w~ \text{contains at least three }1\text{'s}\}$
                    \begin{align*}
                        (0+1)^*1(0+1)^*1(0+1)^*1(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{contains the substring }0101\}$
                    \begin{align*}
                        (0+1)^*0101(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{has length at least }3\text{ and its third symbol is a }0\}$
                    \begin{align*}
                        (0+1)^{2}0(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{starts with }0\text{ and has odd length, or starts with }1\text{ and has even length}\}$
                    \begin{align*}
                        0(0+1)((0+1)(0+1))^* + 1((0+1)(0+1))^*
                    \end{align*}
              \item $\{w|w~ \text{doesn't contain the substring }110\}$
                    \begin{align*}
                        (0+1)^*- 110
                    \end{align*}
              \item $\{w|\text{the length of }w\text{ is at most }5\}$
                    \begin{align*}
                        (0+1)?(0+1)?(0+1)?(0+1)?(0+1)?
                    \end{align*}
              \item $\{w|w~ \text{is any string except }11\text{ and }111\}$
                    \begin{align*}
                        (0+1)^* - 11 - 111
                    \end{align*}
              \item $\{w|\text{ every odd position of }w\text{ is a }1\}$
                    \begin{align*}
                        1((0+1)1)^*
                    \end{align*}
              \item $\{w|w~ \text{contains at least two }0\text{'s and at most one }1\}$
                    \begin{align*}
                        TODO
                    \end{align*}
              \item $\{\epsilon,0\}$
                    \begin{align*}
                        0?
                    \end{align*}
              \item $\{w|w~ \text{contains an even number of }0\text{'s, or contains exactly two }1\text{'s}\}$
                    \begin{align*}
                        TODO
                    \end{align*}
              \item The empty set
                    \begin{align*}
                        \emptyset
                    \end{align*}
              \item All strings except the empty string
                    \begin{align*}
                        (0+1)^+
                    \end{align*}
          \end{enumerate}
\end{enumerate}
