\begin{enumerate}

    \item [1.13]

          Let $F$ be the language of all strings over $\{0,1\}$ that do not contain a pair of $1$s that are separated by an odd number of symbols. Give the state diagram of a DFA with five states that recognizes $F$. (You may find it helpful first to find a 4-state NFA for the complement of $F$.) blab

          $\overline{F} = \{w|w~ \text{contains a pair of }1\text{'s that are separated by an odd number of symbols}\}$

          \begin{figure}[H]
              \centering
              \begin{tikzpicture}
                  \node[state, initial] (q0) {};
                  \node[state, right of=q0] (q1) {};
                  \node[state, above of=q1] (q2) {};
                  \node[state, accepting, right of=q1] (q3) {};
                  \draw
                  (q0) edge[above] node{$1$} (q1)
                  (q0) edge[bend right, below] node{$1$} (q2)
                  (q2) edge[above] node{$1$} (q3)
                  (q2) edge[bend right, above] node{$1$} (q3)
                  (q3) edge[loop above] node{$0$} (q3);
              \end{tikzpicture}
              \caption{NFA with four states that recognizes $\overline{F}$}
          \end{figure}
    \item [1.14]
          \begin{enumerate}
              \item Show that if $M$ is a DFA that recognizes language $B$, swapping the accept and nonaccept states in $M$ yields a new DFA recognizing the complement of $B$.Conclude that the class of regular languages is closed under complement.

                    Every state in DFA has a transition for every symbol in the alphabet. For every possible word, the DFA will end up in either an accept state or a nonaccept state. If we swap the accept and nonaccept states in $M$, the new DFA will accept the complement of the language $B$.

              \item Show by giving an example that if $M$ is an NFA that recognizes language $C$, swapping the accept and non-accept states in $M$ doesnâ€™t necessarily yield a new NFA that recognizes the complement of $C$. Is the class of languages recognized by NFAs closed under complement? Explain your answer.

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, initial] (q0) {};
                            \node[state, accepting, right of=q0] (q1) {};
                            \draw
                            (q0) edge[above] node{$0,1$} (q1)
                            (q0) edge[loop above] node{$0$} (q0);
                        \end{tikzpicture}
                        \caption{example NFA}
                        \begin{tikzpicture}
                            \node[state, accepting, initial] (q0) {};
                            \node[state, right of=q0] (q1) {};
                            \draw
                            (q0) edge[above] node{$0,1$} (q1)
                            (q0) edge[loop above] node{$0$} (q0);
                        \end{tikzpicture}
                        \caption{example NFA with changed states acceptance}
                    \end{figure}

                    NFA accepts a string if there is at least one path that leads to an accept state. If we swap the accept and non-accept states in $M$, the new NFA will not necessarily accept the complement of the language $C$. The class of languages recognized by NFAs is not closed under complement.
          \end{enumerate}
    \item [1.15]
          Give a counter example to show that the following construction fails to prove Theorem 1.49, the closure of the class of regular languages under the star operation. Let $N_1 = (Q_1,\Sigma,\delta_1,q_1,F_1)$ recognize $A_1$. Construct $N = (Q_1,\Sigma,\delta,q_1,F)$ as follows. $N$ is supposed to recognize $A_1^\ast$.
          \begin{enumerate}
              \item The states of $N$ are the states of $N_1$.
              \item The start state of $N$ is the same as the start state of $N_1$.
              \item $F =\{q_1\} \cup F_1$.

                    The accept states F are the old accept states plus its start state.
              \item Define $\delta$ so that for any $q \in Q_1$ and any $a \in \Sigma_\epsilon$,
                    $$\delta(q,a)=
                        \begin{cases}
                            \delta_1(q,a)              & q \notin F_1~ \text{or }a \neq \epsilon \\
                            \delta_1(q,a) \cup \{q_1\} & q \in F_1~ \text{and }a = \epsilon.
                        \end{cases}
                    $$
          \end{enumerate}
          (Suggestion: Show this construction graphically, as in Figure 1.50.)

          \begin{figure}[H]
              \centering
              \begin{tikzpicture}

                  \node[state, initial] (q0) {};
                  \node[state, right of=q0, minimum size=0.5cm] (q02) {};
                  \node[state, above of=q02, minimum size=0.5cm] (q01) {};
                  \node[state, below of=q02, minimum size=0.5cm] (q03) {};
                  \node[state, accepting, above right of=q02] (q2) {};
                  \node[state, accepting, below of=q2] (q3) {};
              \end{tikzpicture}
              \caption{NFA $N_1$}
          \end{figure}
          \begin{figure}[H]
              \centering
              \begin{tikzpicture}
                  \node[state, accepting, initial] (q0) {};
                  \node[state, right of=q0, minimum size=0.5cm] (q02) {};
                  \node[state, above of=q02, minimum size=0.5cm] (q01) {};
                  \node[state, below of=q02, minimum size=0.5cm] (q03) {};
                  \node[state, accepting, above right of=q02] (q2) {};
                  \node[state, accepting, below of=q2] (q3) {};
                  \draw
                  (q2) edge[bend right, above] node{$\epsilon$} (q0)
                  (q3) edge[bend left, above] node{$\epsilon$} (q0);
              \end{tikzpicture}
              \caption{construction of NFA $N_1$}
          \end{figure}

          \begin{figure}[H]
              \centering
              \begin{tikzpicture}
                  \node[state, initial] (q0) {};
                  \node[state, accepting, right of=q0] (q1) {};
                  \draw
                  (q0) edge[bend right, above] node{$0$} (q1)
                  (q1) edge[bend right, above] node{$1$} (q0);
              \end{tikzpicture}
              \caption{counter example of NFA $N_1$}
          \end{figure}
    \item [1.16]
          Use the construction given in Theorem 1.39 to convert the following two nondeterministic finite automata to equivalent deterministic finite automata.
          \begin{enumerate}
              \item

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, accepting, initial] (q1) {$1$};
                            \node[state, below of=q0] (q2) {$2$};
                            \draw
                            (q1) edge[bend right, left] node{$a,b$} (q2)
                            (q2) edge[bend right, right] node{$b$} (q1)
                            (q1) edge[loop right] node{$a$} (q1);
                        \end{tikzpicture}
                        \caption{NFA $A$}
                    \end{figure}
                    $A^\prime = (Q^\prime, \Sigma, \delta^\prime, \{1\}, F^\prime)$

                    $Q^\prime = \{\emptyset,\{1\},\{2\},\{1,2\}\}$

                    $\Sigma = \{a,b\}$

                    $F^\prime = \{\{1\},\{1,2\}\}$

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, accepting, initial] (q1) {$\{1\}$};
                            \node[state, below of=q0] (q2) {$\{2\}$};
                            \node[state, below of=q2] (q3) {$\emptyset$};
                            \node[state, accepting, right of=q2] (q4) {$\{1,2\}$};
                            \draw
                            (q1) edge[bend right, left] node{$b$} (q2)
                            (q2) edge[bend left, left] node{$a$} (q3)
                            (q3) edge[loop left] node{$a,b$} (q3)
                            (q1) edge[loop right] node{$a$} (q1)
                            (q4) edge[loop right] node{$a,b$} (q4)
                            (q2) edge[bend right, right] node{$b$} (q1);
                        \end{tikzpicture}
                        \caption{DFA $A^\prime$}
                    \end{figure}
              \item
                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, initial] (q1) {$1$};
                            \node[state, accepting, right of=q1] (q2) {$2$};
                            \node[state, below left of=q2] (q3) {$3$};
                            \draw
                            (q1) edge[bend right, above] node{$\epsilon$} (q2)
                            (q1) edge[bend right, right] node{$a$} (q3)
                            (q2) edge[bend right, above] node{$a$} (q1)
                            (q3) edge[bend right, right] node{$a,b$} (q2)
                            (q3) edge[loop right] node{$b$} (q3);
                        \end{tikzpicture}
                        \caption{NFA $B$}
                    \end{figure}
                    $B^\prime = (Q^\prime, \Sigma, \delta^\prime, \{1\}, F^\prime)$

                    $Q^\prime = \{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\},\{1,2,3\}\}$

                    $\Sigma = \{a,b\}$

                    $F^\prime = \{\{2\},\{1,2\},\{2,3\},\{1,2,3\}\}$

                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state] (q1) {$\{1\}$};
                            \node[state, accepting, right of=q1] (q2) {$\{2\}$};

                            \node[state, accepting, below right of=q2, initial] (q5) {$\{1,2\}$};
                            \node[state, below left of=q5] (q4) {$\emptyset$};

                            \node[state, right of=q5] (q6) {$\{1,3\}$};
                            \node[state, above of=q6] (q3) {$\{3\}$};
                            \node[state, accepting, right of=q6] (q7) {$\{2,3\}$};
                            \node[state, accepting, right of=q7] (q8) {$\{1,2,3\}$};
                            \draw
                            (q1) edge[left, above] node{$a$} (q6)
                            (q1) edge[bend right, left] node{$b$} (q4)
                            (q2) edge[right, below left] node{$b$} (q4)
                            (q3) edge[bend left, above right] node{$b$} (q7)
                            (q3) edge[above] node{$a$} (q2)

                            (q2) edge[bend right, above] node{$a$} (q1)
                            (q7) edge[bend left, below] node{$a$} (q5)
                            (q7) edge[loop above] node{$b$} (q7)
                            (q8) edge[bend right, above] node{$b$} (q7)

                            (q5) edge[right, below] node{$a$} (q6)
                            (q5) edge[right, below] node{$b$} (q4)

                            (q6) edge[right, below] node{$a,b$} (q7)

                            (q8) edge[loop right] node{$a$} (q8);
                        \end{tikzpicture}
                        \caption{DFA $B^\prime$}
                    \end{figure}
          \end{enumerate}
    \item [1.17]
          \begin{enumerate}
              \item Give an NFA recognizing the language $(01 \cup 001 \cup 010)^\ast$
                    \begin{figure}[H]
                        \centering
                        \begin{tikzpicture}
                            \node[state, initial] (q0) {};
                            \node[state, above right of=q0] (q1) {};
                            \node[state, right of=q0] (q2) {};
                            \node[state, below right of=q0] (q3) {};
                            \node[state, right of=q1] (q11) {};
                            \node[state, right of=q11] (q12) {};

                            \node[state, right of=q2] (q21) {};
                            \node[state, right of=q21] (q22) {};
                            \node[state, right of=q22] (q23) {};
                            \node[state, right of=q3] (q31) {};
                            \node[state, right of=q31] (q32) {};
                            \node[state, right of=q32] (q33) {};

                            \node[state, accepting, right of=q23] (qend) {};
                            \draw
                            (q0) edge[above] node{$\epsilon$} (q1)
                            (q0) edge[above] node{$\epsilon$} (q2)
                            (q0) edge[above] node{$\epsilon$} (q3)
                            (q1) edge[above] node{$0$} (q11)
                            (q11) edge[above] node{$1$} (q12)
                            (q2) edge[above] node{$0$} (q21)
                            (q21) edge[above] node{$0$} (q22)
                            (q22) edge[above] node{$1$} (q23)

                            (q3) edge[above] node{$0$} (q31)
                            (q31) edge[above] node{$1$} (q32)
                            (q32) edge[above] node{$0$} (q33)

                            (q12) edge[above] node{$\epsilon$} (qend)
                            (q23) edge[above] node{$\epsilon$} (qend)
                            (q33) edge[above] node{$\epsilon$} (qend)
                            (qend) edge[bend right=70, above] node{$\epsilon$} (q0);
                        \end{tikzpicture}
                        \caption{NFA recognizing the language $(01 \cup 001 \cup 010)^\ast$}
                    \end{figure}
              \item Convert this NFA to an equivalent DFA. Give only the portion of the DFA that is reachable from the start state.
          \end{enumerate}
    \item [1.18]
          Give regular expressions generating the languages of Exercise 1.6.
          \begin{enumerate}
              \item $\{w|w~ \text{begins with a }1\text{ and ends with a }0\}$
                    \begin{align*}
                        1(0+1)^*0
                    \end{align*}
              \item $\{w|w~ \text{contains at least three }1\text{'s}\}$
                    \begin{align*}
                        (0+1)^*1(0+1)^*1(0+1)^*1(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{contains the substring }0101\}$
                    \begin{align*}
                        (0+1)^*0101(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{has length at least }3\text{ and its third symbol is a }0\}$
                    \begin{align*}
                        (0+1)^{2}0(0+1)^*
                    \end{align*}
              \item $\{w|w~ \text{starts with }0\text{ and has odd length, or starts with }1\text{ and has even length}\}$
                    \begin{align*}
                        0(0+1)((0+1)(0+1))^* + 1((0+1)(0+1))^*
                    \end{align*}
              \item $\{w|w~ \text{doesn't contain the substring }110\}$
                    \begin{align*}
                        (0+1)^*- 110
                    \end{align*}
              \item $\{w|\text{the length of }w\text{ is at most }5\}$
                    \begin{align*}
                        (0+1)?(0+1)?(0+1)?(0+1)?(0+1)?
                    \end{align*}
              \item $\{w|w~ \text{is any string except }11\text{ and }111\}$
                    \begin{align*}
                        (0+1)^* - 11 - 111
                    \end{align*}
              \item $\{w|\text{ every odd position of }w\text{ is a }1\}$
                    \begin{align*}
                        1((0+1)1)^*
                    \end{align*}
              \item $\{w|w~ \text{contains at least two }0\text{'s and at most one }1\}$
                    \begin{align*}
                        TODO
                    \end{align*}
              \item $\{\epsilon,0\}$
                    \begin{align*}
                        0?
                    \end{align*}
              \item $\{w|w~ \text{contains an even number of }0\text{'s, or contains exactly two }1\text{'s}\}$
                    \begin{align*}
                        TODO
                    \end{align*}
              \item The empty set
                    \begin{align*}
                        \emptyset
                    \end{align*}
              \item All strings except the empty string
                    \begin{align*}
                        (0+1)^+
                    \end{align*}
          \end{enumerate}
\end{enumerate}
